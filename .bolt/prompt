Unified System-Wide Bolt Instructions for TransportMat
Objective: To ensure Bolt operates with a system-wide understanding of the app's complexity â€” respecting the full integration between UI, backend, user workflows, and the data ecosystem.

ğŸ§  1. System-Wide Thinking, Not Code-Only Fixes
Bolt must not operate as a code-fixer in isolation. Every change must be evaluated in the broader context of the system â€” including frontend usability, Firebase backend integrity, user flow continuity, visual alignment, and downstream impact.

A trip entry form is not just a form. It's connected to backend data models, PDF generation, update modals, cost logic, reporting, debrief exports, syncing to dashboards, and flags. Bolt must simulate the full chain reaction of a change before finalizing it.

Any â€œfixâ€ that addresses only a single bug but breaks associated functionality (trip visibility, filter performance, cost sync, etc.) is a regression â€” not a success.

ğŸ” 2. True Integration: Frontend â†” Backend Must Be Authentically Synced
The frontend (hosted via Netlify) and backend (hosted on Firebase) are not two separate applications. They are two faces of one platform.

Changing something in Netlify (like netlify.toml) without verifying that Firestoreâ€™s collections, functions, or rules still align with frontend queries is unacceptable. Likewise, backend validation or document structures cannot change without syncing the frontend data consumers (like onSnapshot, getDocs, filters, or modals).

Bolt must always assume that:

Every UI action needs a verified backend endpoint

Every backend write must reflect in a usable frontend state

Every deployment must be visually and functionally confirmed

ğŸ“„ 3. Handle All Interfaces: Manual, CSV, Excel, PDF Uploads
This system is not purely digital-input driven. Bolt must accommodate and preserve:

âœ… Manual form entry with validation

âœ… CSV imports for bulk trip/diesel entries

âœ… Excel data parsing and feedback

âœ… PDF generation and upload management (e.g. debriefs, invoices)

âœ… File download actions with correct headers and naming

âœ… Upload feedback with confirmations and error states

Each of these components must work seamlessly in parallel, and not be overwritten by code optimizations that do not test all formats.

ğŸ› 4. Filters, Views, and State Must Be Integrated Logically
Filters are not visual candy â€” theyâ€™re core to operational control. Every table view (e.g. ActiveTrips, CompletedTrips, DieselLogs, Flags) must:

Load reliably from Firestore using validated filters

Allow multi-criteria selection (e.g. date, driver, fleet, trip status)

Be state-aware â€” meaning changes should reflect across all dashboards and modals

Avoid duplication or â€œghostâ€ data caused by mismatched state vs backend

Bolt must confirm that filtered views, modals, and backend collections remain in sync â€” even when editing, deleting, or importing data.

ğŸ§° 5. Coding Must Respect the Final Product â€” Not Just â€œMake It Workâ€
A working backend that delivers broken UI is a failure. A UI that looks pretty but doesnâ€™t bind properly to Firestore is a liability.

Bolt must care as much about:

Spacing

Input behavior

Button visibility

Visual feedback (errors, success toasts, loaders)

Mobile responsiveness

â€¦as about whether a function returns 200 OK. Because users donâ€™t see your Firestore query â€” they experience the interface.

No change may be marked "complete" unless the final UI, form behavior, and state feedback reflect that change without compromise.

ğŸ§± 6. Data Structure Changes Must Cascade System-Wide
When Bolt updates a Firestore document structure (e.g. adding a field like tripStatus), it must:

Reflect in all queries, filters, modals, and exports

Be validated in trip form, edit modal, and CSV import

Be used in visual cues (e.g. trip tags: Completed / Active / Flagged)

Failure to update one place (e.g. the export PDF) creates invisible bugs that only emerge in production. Bolt must propagate changes system-wide.

ğŸ§ª 7. Testing Must Include the Chain Reaction
Testing must not stop at one component.

When Bolt fixes a TripForm, it must verify:

Trip appears in ActiveTripsDashboard

That same trip can be completed

Costs can be added and saved

Reports can export the data

Flags (if any) still apply correctly

PDF and Excel still handle that tripâ€™s data

Unit tests are not enough. Bolt must mentally simulate or actually walk the workflow â€” as an operations manager would.

âš ï¸ 8. Visual Design Is Functional â€” Not Optional
Theme, layout, spacing, and alignment must reflect a clean, modern, analytical interface. Bolt may not revert styling decisions or break Tailwind class hierarchies to "just make it work."

Each page and modal must:

Match layout expectations

Use consistent card/grid structures

Maintain responsive behavior across viewports

The visual output is the product â€” not an afterthought.

ğŸ”’ 9. Data Integrity, Permissions & Sync Must Be Enforced
Bolt must:

Respect Firestore rules and auth boundaries

Avoid unauthenticated writes unless explicitly public

Prevent duplicate records during imports (via loadRef/ID checks)

Use Firestore merge logic for updates, not overwrites

Security, structure, and user clarity must come before coding shortcuts.

âœ… Final Instruction: Precision Before Performance, Purpose Before Patching
Boltâ€™s goal is not to "make it work." The goal is to make it real, integrated, testable, maintainable, and consistent. Each part must fit with every other part â€” or it is a liability, not a feature.

If a fix breaks something else, it is not a fix.
If the code is clean but the UX breaks, it is not finished.
If the backend syncs but the UI does not reflect it, it is not deployed.

Every pull request, commit, and deployment must pass this filter.

 10. Web Book Integrations: Real-Time System Entry Points
The Web Books (Google Sheets + Apps Script deployments) are first-class data sources, not temporary tools. They power the core ingestion of trip, diesel, and driver behavior data into Firestore and therefore directly affect the live dashboards and reporting modules.

Bolt must treat these as official system endpoints, equivalent in importance to frontend forms or API requests.

ğŸ” Web Book Functions to Support
Each Google Web Book integration must support the following user operations in full:

âœ… Edit: Change previously submitted rows and update Firestore accordingly

âœ… Delete: Remove entries from the Web Book and reflect the deletion in the app's Firestore data (if allowed)

âœ… View: Ensure accurate mapping from Google Sheets to app tables and reports

âœ… Update: Propagate changes in the Web Book to Firestore reliably

âœ… Submit: Initial ingestion from the Web Book must validate structure, type, and completeness

Every one of these actions must function end-to-end, and not partially. Submitting data from the Web Book must result in visible, actionable records in the frontend dashboards. The reverse is also true: if a record is updated or deleted in the app, and that data originated from the Web Book, Bolt must preserve relational consistency.

ğŸ“¡ Webhook Responsiveness and Debugging
Bolt must verify that the Google Apps Script webhooks:

Accept POST payloads without failure

Return success/failure states clearly

Log all skipped, imported, and errored entries for traceability

Handle out-of-sync or repeated loadRefs gracefully (no duplicates or overwrite loops)

This includes managing:

importTripsFromWebBook

importDriverBehaviorWebhook

Any future endpoints like importDieselFromWebBook

All changes to webhook logic must be mirrored in frontend expectations: if a tripStatus or driverName is changed in the Web Book, the frontend must reflect it instantly without refresh or manual reload.

ğŸ› ï¸ Firestore Sync Must Be Atomic and Idempotent
Web Book ingestion logic must:

Use merge: true when writing to Firestore to avoid data loss

Create only one document per unique loadRef or tripId

Reject malformed data with structured error logging (in the GAS log and optionally in Firestore as a failedImports collection)

Update only when thereâ€™s actual data change (Bolt must not create a new record on every webhook hit)

ğŸ›ï¸ Frontend Integration with Web Book Entries
Each entry from the Web Book must:

Appear correctly in all dashboards (ActiveTrips, CompletedTrips, FlagsDashboard)

Be editable inside modals with full form support (pre-filled fields, validation, backend update)

Support status transitions: trip â†’ costed â†’ completed

Be deletable or overrideable via UI with confirmation and full Firestore sync

Trigger filters, reporting, and exports as normal system entries

There must be no difference between data added via the Web Book and data entered manually via the Trip Form.

ğŸš¦ Boltâ€™s Responsibilities for Web Book Integration
Bolt must:

Audit every webhook connection between Sheets and Firebase

Verify Firestore writes are correctly shaped, typed, and timestamped

Ensure frontend correctly renders, filters, and allows editing of Web Bookâ€“originated data

Prevent data duplication across sources

Respect any additional fields added in the Web Book (e.g., clientType, runnerFee, delayReason)

Bolt must also provide:

âš ï¸ Clear warning logs when data sync fails

ğŸ“ˆ Visual sync status indicators (e.g., â€œImported from Web Bookâ€ or â€œLast Synced: Xâ€)

If any trip, diesel entry, or driver event is edited or updated in the Web Book, and this does not reflect in the app â€” the system is broken. Bolt must ensure two-way traceability and confidence in the integrity of Web Book data.